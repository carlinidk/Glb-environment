<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Glb-Controller Split-Screen</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* Split Screen Divider */
        #divider {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255,255,255,0.2);
            z-index: 5;
            pointer-events: none;
        }

        /* Main UI Container */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* --- Settings & Menu --- */
        #settings-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 101;
        }

        #custom-menu {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            width: 250px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: 0.3s;
            z-index: 100;
        }
        #custom-menu.visible { transform: translateX(-50%) scale(1); }

        .menu-item { color: white; font-size: 0.9rem; }
        .file-upload {
            display: inline-block;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            border: 1px dashed #555;
            text-align: center;
        }
        input[type="file"] { display: none; }

        #controls-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 0.8rem;
            z-index: 50;
        }

        /* Drop Zone */
        #drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 30%;
            border: 3px dashed #888;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            color: #fff;
            pointer-events: auto; 
            cursor: pointer;
            z-index: 20;
        }
        #drop-zone.hidden { display: none; }

        /* --- CONTROLS --- */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .player-label {
            position: absolute;
            top: -30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-weight: bold;
            font-size: 14px;
        }

        .d-pad {
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            backdrop-filter: blur(2px);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .d-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            font-size: 1.2rem;
            width: 45px;
            height: 45px;
            transition: background 0.1s;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.6); color: black; }

        /* Positioning buttons within D-pad */
        .btn-up { top: 10px; left: 50%; transform: translateX(-50%); }
        .btn-down { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .btn-left { top: 50%; left: 10px; transform: translateY(-50%); }
        .btn-right { top: 50%; right: 10px; transform: translateY(-50%); }

    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>

    <input type="file" id="file-input" accept=".glb,.gltf">

    <div id="divider"></div>

    <div id="ui-container">
        <div id="settings-btn" title="Customize">‚öôÔ∏è</div>
        
        <div id="custom-menu">
            <div class="menu-item">
                <span style="display:block; margin-bottom:5px;">Floor Texture</span>
                <label class="file-upload">Select Image...<input type="file" id="floor-input" accept="image/png, image/jpeg"></label>
            </div>
            <div class="menu-item" style="margin-top:10px;">
                <span style="display:block; margin-bottom:5px;">Skybox</span>
                <label class="file-upload">Select Image...<input type="file" id="sky-input" accept="image/png, image/jpeg"></label>
            </div>
        </div>

        <div id="controls-info">
            <span id="status">Waiting for model...</span>
        </div>

        <div id="drop-zone">
            <p style="font-size: 1.5rem; margin-bottom: 10px;">üìÇ Load Model (P1 & P2)</p>
            <p style="font-size: 0.9rem; color: #ccc;">Tap or Drag & Drop .GLB</p>
        </div>

        <div class="touch-controls">
            <div class="d-pad" id="p1-pad">
                <div class="player-label">PLAYER 1 (WASD)</div>
                <div id="p1-w" class="d-btn btn-up">‚ñ≤</div>
                <div id="p1-s" class="d-btn btn-down">‚ñº</div>
                <div id="p1-a" class="d-btn btn-left">‚óÄ</div>
                <div id="p1-d" class="d-btn btn-right">‚ñ∂</div>
            </div>

            <div class="d-pad" id="p2-pad">
                <div class="player-label">PLAYER 2 (ARROWS)</div>
                <div id="p2-up" class="d-btn btn-up">‚ñ≤</div>
                <div id="p2-down" class="d-btn btn-down">‚ñº</div>
                <div id="p2-left" class="d-btn btn-left">‚óÄ</div>
                <div id="p2-right" class="d-btn btn-right">‚ñ∂</div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // --- CONFIG ---
        const WALK_SPEED = 5;
        const ROTATION_SPEED = 3;
        const CAM_DIST = 5;
        const CAM_HEIGHT = 4;

        // --- GLOBALS ---
        let scene, renderer, clock;
        let camera1, camera2;
        let floorMesh, gridHelper;

        // Input State
        const inputs = {
            p1: { w: false, s: false, a: false, d: false },
            p2: { up: false, down: false, left: false, right: false }
        };

        // Player Objects
        const players = [
            { id: 1, model: null, mixer: null, actions: {}, activeAction: null, pos: new THREE.Vector3(-2, 0, 0) },
            { id: 2, model: null, mixer: null, actions: {}, activeAction: null, pos: new THREE.Vector3(2, 0, 0) }
        ];

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 10, 60);

            // 2. Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(3, 10, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 3. Environment
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, depthWrite: false });
            floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);
            
            gridHelper = new THREE.GridHelper(200, 80, 0x888888, 0x444444);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // 4. Cameras
            const aspect = (window.innerWidth / 2) / window.innerHeight;
            camera1 = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera2 = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);

            // 5. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            // Enable Scissor Test for Split Screen
            renderer.setScissorTest(true);
            container.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // 6. Interactions
            setupFileHandling();
            setupInputs();
            setupCustomization();

            window.addEventListener('resize', onWindowResize);
        }

        // --- MODEL LOADING & CLONING ---
        function loadModelFromFile(file) {
            const url = URL.createObjectURL(file);
            const loader = new GLTFLoader();
            const statusDiv = document.getElementById('status');
            const dropZone = document.getElementById('drop-zone');

            statusDiv.innerText = "Loading...";

            // Clean up old models
            players.forEach(p => {
                if (p.model) scene.remove(p.model);
                p.model = null;
                p.mixer = null;
            });

            loader.load(url, function(gltf) {
                dropZone.classList.add('hidden');
                statusDiv.innerText = `Loaded: ${file.name}`;

                // Setup Player 1
                setupPlayer(players[0], gltf.scene, gltf.animations);
                
                // Setup Player 2 (Clone)
                // Note: SkeletonUtils is required to clone rigged meshes properly
                const clone = SkeletonUtils.clone(gltf.scene);
                setupPlayer(players[1], clone, gltf.animations);

            }, undefined, (err) => {
                console.error(err);
                statusDiv.innerText = "Error loading model.";
            });
        }

        function setupPlayer(player, modelScene, animations) {
            player.model = modelScene;
            player.model.position.copy(player.pos);
            
            player.model.traverse(o => {
                if (o.isMesh) o.castShadow = true;
            });

            scene.add(player.model);

            // Setup Animations
            if (animations && animations.length > 0) {
                player.mixer = new THREE.AnimationMixer(player.model);
                
                const findClip = (name) => animations.find(c => c.name.toLowerCase().includes(name)) || animations[0];
                
                player.actions['idle'] = player.mixer.clipAction(findClip('idle'));
                player.actions['walk'] = player.mixer.clipAction(findClip('walk'));
                player.actions['run'] = player.mixer.clipAction(findClip('run'));

                player.activeAction = player.actions['idle'];
                player.activeAction.play();
            }
        }

        function fadeAction(player, name, duration) {
            if (!player.actions[name]) return;
            const newAction = player.actions[name];
            if (player.activeAction !== newAction) {
                player.activeAction.fadeOut(duration);
                newAction.reset().fadeIn(duration).play();
                player.activeAction = newAction;
            }
        }

        // --- INPUT HANDLING ---
        function setupInputs() {
            // Keyboard
            document.addEventListener('keydown', (e) => handleKey(e.key, true));
            document.addEventListener('keyup', (e) => handleKey(e.key, false));

            // Touch P1
            bindTouch('p1-w', 'p1', 'w');
            bindTouch('p1-s', 'p1', 's');
            bindTouch('p1-a', 'p1', 'a');
            bindTouch('p1-d', 'p1', 'd');

            // Touch P2
            bindTouch('p2-up', 'p2', 'up');
            bindTouch('p2-down', 'p2', 'down');
            bindTouch('p2-left', 'p2', 'left');
            bindTouch('p2-right', 'p2', 'right');
        }

        function handleKey(key, pressed) {
            const k = key.toLowerCase();
            // P1 WASD
            if(k === 'w') inputs.p1.w = pressed;
            if(k === 's') inputs.p1.s = pressed;
            if(k === 'a') inputs.p1.a = pressed;
            if(k === 'd') inputs.p1.d = pressed;
            
            // P2 Arrows
            if(key === 'ArrowUp') inputs.p2.up = pressed;
            if(key === 'ArrowDown') inputs.p2.down = pressed;
            if(key === 'ArrowLeft') inputs.p2.left = pressed;
            if(key === 'ArrowRight') inputs.p2.right = pressed;
        }

        function bindTouch(elementId, playerKey, inputKey) {
            const el = document.getElementById(elementId);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); inputs[playerKey][inputKey] = true; });
            el.addEventListener('touchend', (e) => { e.preventDefault(); inputs[playerKey][inputKey] = false; });
        }

        // --- MAIN LOOP ---
        function updatePlayerMovement(player, delta, inputState) {
            if (!player.model) return;

            let isMoving = false;
            // P1 uses w/s/a/d, P2 uses up/down/left/right
            // We map generic logic: up/down/turn
            const up = player.id === 1 ? inputState.w : inputState.up;
            const down = player.id === 1 ? inputState.s : inputState.down;
            const left = player.id === 1 ? inputState.a : inputState.left;
            const right = player.id === 1 ? inputState.d : inputState.right;

            if (left) player.model.rotation.y += ROTATION_SPEED * delta;
            if (right) player.model.rotation.y -= ROTATION_SPEED * delta;

            if (up) {
                player.model.translateZ(WALK_SPEED * delta);
                isMoving = true;
            }
            if (down) {
                player.model.translateZ(-WALK_SPEED * delta);
                isMoving = true;
            }

            if (player.mixer) {
                fadeAction(player, isMoving ? 'walk' : 'idle', 0.2);
                player.mixer.update(delta);
            }
        }

        function updateCameras() {
            // Camera 1 Follow Player 1
            if (players[0].model) {
                const p1 = players[0].model;
                const offset = new THREE.Vector3(0, CAM_HEIGHT, -CAM_DIST).applyMatrix4(p1.matrixWorld);
                camera1.position.lerp(offset, 0.1);
                camera1.lookAt(p1.position.clone().add(new THREE.Vector3(0,1,0)));
            }
            
            // Camera 2 Follow Player 2
            if (players[1].model) {
                const p2 = players[1].model;
                const offset = new THREE.Vector3(0, CAM_HEIGHT, -CAM_DIST).applyMatrix4(p2.matrixWorld);
                camera2.position.lerp(offset, 0.1);
                camera2.lookAt(p2.position.clone().add(new THREE.Vector3(0,1,0)));
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Update Logic
            updatePlayerMovement(players[0], delta, inputs.p1);
            updatePlayerMovement(players[1], delta, inputs.p2);
            updateCameras();

            // Render Split Screen
            const w = window.innerWidth;
            const h = window.innerHeight;
            const halfW = w / 2;

            // Render Left (P1)
            renderer.setViewport(0, 0, halfW, h);
            renderer.setScissor(0, 0, halfW, h);
            renderer.render(scene, camera1);

            // Render Right (P2)
            renderer.setViewport(halfW, 0, halfW, h);
            renderer.setScissor(halfW, 0, halfW, h);
            renderer.render(scene, camera2);
        }

        // --- UTILS ---
        function onWindowResize() {
            const halfW = window.innerWidth / 2;
            const aspect = halfW / window.innerHeight;
            camera1.aspect = aspect;
            camera1.updateProjectionMatrix();
            camera2.aspect = aspect;
            camera2.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupFileHandling() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) loadModelFromFile(e.target.files[0]);
            });

            window.addEventListener('dragover', (e) => e.preventDefault());
            window.addEventListener('drop', (e) => {
                e.preventDefault();
                if (e.dataTransfer.files[0]) loadModelFromFile(e.dataTransfer.files[0]);
            });
        }

        function setupCustomization() {
            const textureLoader = new THREE.TextureLoader();
            document.getElementById('floor-input').addEventListener('change', (e) => {
                const f = e.target.files[0];
                if(f) textureLoader.load(URL.createObjectURL(f), (t) => {
                    t.wrapS = t.wrapT = THREE.RepeatWrapping;
                    t.repeat.set(10,10);
                    floorMesh.material.map = t;
                    floorMesh.material.needsUpdate = true;
                    gridHelper.visible = false;
                });
            });
            document.getElementById('sky-input').addEventListener('change', (e) => {
                const f = e.target.files[0];
                if(f) textureLoader.load(URL.createObjectURL(f), (t) => { scene.background = t; scene.fog = null; });
            });

            const btn = document.getElementById('settings-btn');
            const menu = document.getElementById('custom-menu');
            btn.addEventListener('click', () => menu.classList.toggle('visible'));
        }
    </script>
</body>
</html>
